I am implementing format preserving encryption in go-lang based on NIST reccomendation sp 800-38g.

For the NIST pseudocode of functions you will take the following into consideration the following definitions:

BYTELEN(X) = The number of bytes in a byte string, X. 
CIPHK (X) = The output of the designated cipher function of the block cipher under the key K applied to the block X.
LEN(X) = The number of numerals [or bits] in a numeral string [or bit string] X.
LOG(x) = The base 2 logarithm of the real number x > 0.
NUM(X) = The integer that a bit string X represents when the bits are valued indecreasing order of significance.
NUMradix (X) = The number that the numeral string X represents in base radix when the numerals are valued in decreasing order of significance.
PRF(X) = The output of the function PRF applied to the block X; PRF is defined in terms of a given designated cipher function.
REV(X) = Given a numeral string, X, the numeral string that consists of the numerals of X in reverse order.
REVB(X) = Given a byte string, X, the byte string that consists of the bytes of X in reverse order.
STRradix (x) = Given a nonnegative integer x less than radixm, the representation of x as a string of m numerals in base radix, in decreasing order of significance.
FLOOR(x) = The greatest integer that does not exceed the real number x.
CEIL(x) = The least integer that is not less than the real number x. 
[x]s = Given a nonnegative integer x les than 256^s, the representation of x as a string of s bytes.
[i..j] = The set of integers between two integers i and j, including i and j.
x mod m = The nonnegative remainder of the integer x modulo the positive integer m.
X[i] = The ith element of the string X.
X[i..j] = The substring of the string X from X[i] to X[j], including X[i] and X[j].
X⊕Y = The bitwise exclusive-OR of bit strings X and Y whose bit lengths are equal.
X || Y = The concatenation of numeral strings X and Y.
0^s = The bit string that consists of s consecutive ‘0’ bits.

Given two integers i and j with i≤j, the set of integers between i and j, including i and j, is denoted by [i..j]. For example, [2..5]={2, 3, 4, 5}.
Given a real number x and a positive integer m, the remainder of x modulo m, denoted by x mod m, is x – m * floor(x/m). For example, -3 mod 7 = 4, and 13 mod 7 = 6.
Given a positive integer s, 0^s denotes the string that consists of s ‘0’ bits. For example, 0^8= 00000000.
The concatenation operation on bit strings or numeral strings is denoted by ||. For example, 001|| 1011= 0011011, and 31 || 31 8 10= 3 1 31 8 10.
Given bit strings of equal length, the exclusive-OR (XOR) operation, denoted by⊕, specifies the addition, modulo 2, of the bits in corresponding bit positions. For example, 10011⊕10101= 00110.
Given a numeral or bit string X, its length is denoted by LEN(X). For example, LEN(010) = 3.
Given a byte string X—i.e., a bit string that could be represented as the concatenation of a sequence of bytes—the length of X in bytes, i.e., LEN(X)/8, is denoted by BYTELEN(X). For example, BYTELEN(1011100110101100) = 2.
Given a numeral [bit] string X and an index i such that 1 ≤ i ≤ LEN(X), the ith numeral [bit] of X is denoted by X[i]. For a pair of indices (i,j), with 1 ≤ i ≤ j ≤ LEN(X), the substring of numerals [bits] from X[i] to X[j] is denoted by X[i..j]. For example, in base ten, if X = 798137, then X[2] = 9, and X[3..5]=813.

Given a base, radix, and a length, m, there are radixm distinct numeral strings. Given an integer x such that 0 ≤ x < radix^m, the integer-to-string function, denoted by STR_radix^m (x), is the numeral string of length m in base radix that represents x, when the numerals are in decreasing order of significance. For example, STR 124 (559) is the string of four numerals in base 12 that represents 559, namely, 0 3 10 7.
A separate notation is given for the conversion of integers to byte strings, in particular, [x]^s = STR_2^8s (x). For example, [1]^1=00000001.

Given a (non-empty) numeral string X in base radix of length m, the string-to-integer function, denoted by NUM_radix (X), is the integer x that X represents, so that STR_radix^m (x)= X. For example, NUM_5 (00011010)=755.

Similar notation is given for the function that converts bit strings to integers. In particular, given a byte string X, NUM(X) is the integer x that X represents, so that [NUM(X)]^BYTELEN(X)= X. For example, NUM(10000000)=128.

In the next prompts I will provide you the pseudocode from the NIST reccomendation, then my implementation of the functions. You will correct my functions.

---------------------

NIST pseudocode implementation of NUM_radix(X):
```
Prerequisite: Base, radix.
Input:
Numeral string, X.
Output:
Number, x.
Steps:
1. Let x = 0.
2. For i from 1 to LEN(X), let x = x*radix + X[i].
3. Return x.
```
My implementation of NUM_radix(X):
```
// NumRadix(X) function implements Algorithm 1: NUM_radix(X) from NIST Special Publication 800-38G.
// Converts a numeral string to a number based on the given radix.
func NumRadix(X string, radix int) (uint64, error) {
	var x uint64 = 0

	// Validate that the radix is within a reasonable range
	if radix < 2 || radix > 36 {
		return 0, fmt.Errorf("invalid radix: %d. Must be between 2 and 36", radix)
	}

	for i := 0; i < len(X); i++ {
		// Get the value of the current character
		digit, err := strconv.ParseUint(string(X[i]), radix, 32)
		if err != nil {
			return 0, fmt.Errorf("invalid character '%c' for radix %d", X[i], radix)
		}

		x = x*uint64(radix) + digit
	}

	return x, nil
}
```

NIST pseudocode implementation of NUM(X):
```
Input:
Byte string, X, represented in bits.
Output:
Integer, x.
Steps:
1. Let x = 0.
2. For i from 1 to LEN(X), let x = 2x + X[i].
3. Return x.
```

My implementation of NUM(X):
```
// NumBits converts a binary string X, represented in bits, to an integer.
func NumBits(X string) (uint64, error) {
	var x uint64 = 0
	for i := 0; i < len(X); i++ {
		// Check for valid binary characters.
		if X[i] != '0' && X[i] != '1' {
			return 0, fmt.Errorf("invalid character '%c' in binary string", X[i])
		}

		// Convert '0' or '1' to integer 0 or 1 by subtracting '0'.
		bit := X[i] - '0'
		x = 2*x + uint64(bit)
	}

	return x, nil
}
```
NIST pseudocode implementation of STR_radix^m(X):
```
Prerequisites:
Base, radix;
String length, m.
Input:
Integer, x, such that 0 ≤ x < radixm .
Output:
Numeral string, X.
Steps:
1. For i from 1 to m:
i. X[m+1–i] = x mod radix;
ii. x = floor(x/radix).
2. Return X.
```
My implementation of STR_radix^m(X):
```
// StrmRadix converts an integer to a numeral string of a given length and radix,
// as per the NIST specification.
func StrmRadix(x uint64, radix int, m int) (string, error) {
	// Validate that the input x is within the valid range.
	maxValue := power(uint64(radix), uint64(m))
	if x >= maxValue {
		return "", fmt.Errorf("invalid input: x (%d) must be less than radix^m (%d)", x, maxValue)
	}

	// Generate the numeral string in reverse order.
	X := make([]int, m)
	for i := 0; i < m; i++ {
		X[m-1-i] = int(x % uint64(radix)) // X[m+1–i] = x mod radix
		x = x / uint64(radix)             // x = floor(x / radix)
	}

	// Build the result string without spaces.
	result := ""
	for _, digit := range X {
		result += fmt.Sprintf("%d", digit)
	}
	return result, nil
}
```
NIST pseudocode implementation of PRF(X):
```
Prerequisites:
Designated cipher function, CIPH, of an approved 128-bit block cipher;
Key, K, for the block cipher.
Input:
Block string, X.
Output: Block, Y.
Steps:
1. Let m = LEN(X)/128.
2. Let X_1, …, X_m be the blocks for which X = X_1 || … || X_m.
3. Let Y_0 = 0^128, and for j from 1 to m let Y_j = CIPHK (Y_(j–1) ⊕X_j).
4. Return Y_m.
```
My implementation of PRF(X):
```
// PRF function implements Algorithm 6: PRF(X) from NIST Special Publication 800-38G.
// It takes an input block string X and a key K, and returns the result Y.
func PRF(X []byte, K []byte) ([]byte, error) {
	// Ensure the key length is valid (AES-128 requires 16-byte keys).
	block, err := aes.NewCipher(K)
	if err != nil {
		return nil, err
	}

	blockSize := aes.BlockSize // AES block size is always 16 bytes (128 bits)

	// Ensure X is a multiple of the block size.
	if len(X)%blockSize != 0 {
		return nil, errors.New("input length must be a multiple of the AES block size")
	}

	// Number of blocks (m)
	m := len(X) / blockSize

	// Y0 = 0128, i.e., a block of 16 zero bytes.
	Y := make([]byte, blockSize)
	Yaux := make([]byte, blockSize)

	// Iterate over each block Xj
	for j := 0; j < m; j++ {
		Xj := X[j*blockSize : (j+1)*blockSize] // Get block Xj

		// XOR Yj-1 with Xj
		for i := range Y {
			Y[i] ^= Xj[i]
		}

		// Encrypt the result to produce Yj
		block.Encrypt(Yaux, Y)
		copy(Y, Yaux)
	}

	// Return Ym
	return Y, nil
}
```

----

I have implemented the following helper functions:
```
import "encoding/binary"

func UintToBytes(num uint64) []byte {
	var bytes = make([]byte, 8)
	binary.PutUvarint(bytes, num)
	return bytes
}

func power(x uint64, y uint64) uint64 {
	result := uint64(1)
	for i := uint64(0); i < y; i++ {
		result *= x
	}
	return result
}

func intToNBytes(x int, n int) []byte {

	result := make([]byte, n)
	for i := n - 1; i >= 0; i-- {
		result[i] = byte(x % 10)
		x /= 10
	}
	return []byte(result)
}

func uint64ToNBytes(x uint64, n int) []byte {
	result := make([]byte, n)
	for i := n - 1; i >= 0; i-- {
		result[i] = byte(x % 10)
		x /= 10
	}
	return []byte(result)
}
```

NIST pseudocode implementation of FF1.encrypt(K,T,X):
```
Prerequisites:
Designated cipher function, CIPH, of an approved 128-bit block cipher;
Key, K, for the block cipher;
Base, radix;
Range of supported message lengths, [minlen..maxlen];
Maximum byte length for tweaks, maxTlen.
Inputs:
Numeral string, X, in base radix of length n, such that n ∈ [minlen..maxlen];
Tweak T, a byte string of byte length t, such that t ∈ [0..maxTlen].
Output:
Numeral string, Y, such that LEN(Y) = n.
Steps:
1. Let u = floor(n/2); v = n – u.
2. Let A = X[1..u]; B = X[u + 1..n].
3. Let b = ceil(ceil(v * LOG(radix)) / 8).
4.Let d = 4 * ceil(b / 4) + 4.
5. Let P = [1]^1 || [2]^1 || [1]^1 || [radix]^3 || [10]^1 || [u mod 256]^1 || [n]^4 || [t]^4.
6. For i from 0 to 9:
i. Let Q = T || [0]^((−t−b−1) mod 16) || [i]^1 || [NUMradix(B)]^b.
ii. Let R = PRF(P || Q).
iii. Let S be the first d bytes of the following string of ceil(d / 16) blocks:
R || CIPHK (R ⊕[1]^16) || CIPHK (R ⊕[2]^16) … CIPHK (R ⊕[ceil(d/16) –1]^16).
iv. Let y = NUM(S).
v. If i is even, let m = u; else, let m = v.
vi. Let c = (NUMradix (A)+y) mod radix^m .
vii. Let C = STRmradix (c).
viii. Let A = B.
ix. Let B = C.
7. Return A || B.
```

My implementation of FF1.encrypt(K,T,X):
```
// FF1Encrypt performs format-preserving encryption using FF1
func FF1Encrypt(K, T []byte, X string, radix, minlen, maxlen, maxTlen int) (string, error) {
	// Validate input length
	n := len(X)
	if n < minlen || n > maxlen {
		return "", errors.New("input length out of range")
	}

	// Validate the key length as in crypto/aes/cipher.go
	switch len(K) {
	default:
		return "", errors.New("invalid AES key size; must be 16, 24, or 32 bytes")
	case 16, 24, 32:
		break
	}

	// Steps 1 & 2: Split the numeral string X into A and B
	u := n / 2
	v := n - u
	A := X[:u]
	B := X[u:]

	t := len(T)

	// Steps 3 & 4: Calculate the byte length b and block length d
	b := int(math.Ceil(float64(v) * math.Log2(float64(radix)) / 8))
	if b <= 0 {
		return "", errors.New("invalid block length b")
	}
	d := 4*int(math.Ceil(float64(b)/4)) + 4

	// Step 5: Construct P = [1, 2, 1, radix (3 bytes), 10, u mod 256, n (4 bytes), t (4 bytes)]
	radix3bytes := intToNBytes(radix, 3)
	nBytes := intToNBytes(n, 4)
	tBytes := intToNBytes(t, 4)
	P := []byte{1, 2, 1}
	P = append(P, radix3bytes...)
	P = append(P, 10, byte(u%256))
	P = append(P, nBytes...)
	P = append(P, tBytes...)

	// Step 6: Perform the Feistel rounds
	for i := 0; i < 10; i++ {
		// Step 6.i: Construct Q safely
		padding := 16 + (0-t-b-1)%16
		Q := append(T, make([]byte, padding)...)
		Q = append(Q, byte(i)) // append round number i

		// Convert B to a numeric representation
		BNum, err := NumRadix(B, radix)
		if err != nil {
			return "", err
		}
		bNumBytes := uint64ToNBytes(BNum, b)
		Q = append(Q, bNumBytes...)

		//  Check size of Q to be multiple of 16 before calling PRF(P, Q)
		switch len(Q) % 16 {
		default:
			error_str := fmt.Sprint("invalid Q size: ", len(Q), "; must be 16, 24, or 32 bytes")
			return "", errors.New(error_str)
		case 0:
		}

		// Step 6.ii: Compute R = PRF(P, Q)
		R, err := PRF(append(P, Q...), K)
		if err != nil {
			log.Println("P is: ", P, " of length: ", len(P))
			log.Println("Q is: ", Q, " of length: ", len(Q))
			return "", err
		}

		// Step 6.iii: Let S be the first d bytes of CIPHK(R ⊕ [j]16)
		if d <= 0 {
			return "", errors.New("invalid block length d")
		}

		block, err := aes.NewCipher(K)
		if err != nil {
			return "", err
		}

		blockSize := aes.BlockSize // 16 bytes for AES

		dpe16 := int(math.Ceil(float64(d) / float64(blockSize)))
		S := make([]byte, len(R))
		copy(S, R)
		for j := 1; j < dpe16; j++ {
			j16Bytes := intToNBytes(j, 16)
			res := make([]byte, len(R))
			// R xor j
			for k, r := range R {
				res[k] = r ^ j16Bytes[k]
			}
			aux := make([]byte, len(R))
			block.Encrypt(aux, res)

			S = append(S, aux...)
		}

		// for j := 0; j < int(math.Ceil(float64(d)/float64(blockSize))); j++ {
		// 	Rj := make([]byte, aes.BlockSize)
		// 	copy(Rj, append(R, byte(j)))
		// 	encrypted := make([]byte, blockSize)
		// 	block.Encrypt(encrypted, Rj)
		// 	S = append(S, encrypted...)
		// }
		// S = S[:d] // truncate to d bytes

		// Step 6.iv: Let y = NUM(S)
		y, err := NumBits(string(S))
		if err != nil {
			return "", err
		}

		// Step 6.v: Determine m
		m := u
		if i%2 != 0 {
			m = v
		}

		// Step 6.vi: Compute c = (NUMradix(A) + y) mod radix^m
		aNum, err := NumRadix(A, radix)
		if err != nil {
			return "", err
		}
		c := (aNum + y) % power(uint64(radix), uint64(m))

		// Step 6.vii: Let C = STRmradix(c)
		C, err := StrmRadix(c, radix, m)
		if err != nil {
			return "", err
		}

		// Step 6.viii and 6.ix: Swap A and B for next round
		A = B
		B = C
	}

	// Step 7: Return A || B as the encrypted result
	return A + B, nil
}
```